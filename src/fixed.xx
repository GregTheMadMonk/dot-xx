/**
 * @file  fixed.xx
 * @brief Interface file for `dxx.cstd.fixed` module
 */
module;

#include <cstdint>

/**
 * @brief Provides shorter aliases for some fixed-width (and a few other) types
 */
export module dxx.cstd.fixed;

import std;

export {

using u8  = std::uint8_t;
using i8  = std:: int8_t;
using u16 = std::uint16_t;
using i16 = std:: int16_t;

#if defined(UINT32_MAX)
using u32 = std::uint32_t;
using i32 = std:: int32_t;
#endif

#if defined(UINT64_MAX)
using u64 = std::uint64_t;
using i64 = std:: int64_t;
#endif

using uz  = std::size_t;

using uptr  = std::uintptr_t;
using iptr  = std:: intptr_t;

using f32 = float;
using f64 = double;

} // <-- export

template <uz width> struct IOf;
template <> struct IOf< 8> { using T =  i8; };
template <> struct IOf<16> { using T = i16; };
template <> struct IOf<32> { using T = i32; };
template <> struct IOf<64> { using T = i64; };

template <uz width> struct UOf;
template <> struct UOf< 8> { using T =  u8; };
template <> struct UOf<16> { using T = u16; };
template <> struct UOf<32> { using T = u32; };
template <> struct UOf<64> { using T = u64; };

template <uz width> struct FOf;
template <> struct FOf<32> { using T = f32; };
template <> struct FOf<64> { using T = f64; };

export {

template <uz width> using iw = IOf<width>::T;
template <uz width> using uw = UOf<width>::T;
template <uz width> using fw = FOf<width>::T;

} // <-- export

static_assert(std::same_as< iw<8>,  i8>);
static_assert(std::same_as<iw<16>, i16>);
static_assert(std::same_as<iw<32>, i32>);
static_assert(std::same_as<iw<64>, i64>);
static_assert(std::same_as< uw<8>,  u8>);
static_assert(std::same_as<uw<16>, u16>);
static_assert(std::same_as<uw<32>, u32>);
static_assert(std::same_as<uw<64>, u64>);
static_assert(std::same_as<fw<32>, f32>);
static_assert(std::same_as<fw<64>, f64>);
