/**
 * @file  url.xx
 * @brief URL encoding and decoding
 */
export module dxx.http:url;

import dxx.assert;
import dxx.cstd.fixed;
import std;

namespace dxx::http::url {

inline constexpr
char hex_to_half(char c) {
    if !consteval {
        dxx::assert::debug(('0' <= c && c <= '9') || ('A' <= c && (c <= 'F')));
    }
    auto off1 = c - '0';
    return (off1 < 10) * off1 + (off1 >= 10) * (c - 'A' + 10);
} // <-- forbit_to_hex(c)

inline constexpr
char half_to_hex(char c) {
    if !consteval {
        dxx::assert::debug(c < 16);
    }
    return (c < 10) * ('0' + c) + (c >= 10) * ('A' + c - 10);
} // <-- hex_to_fourbit(c)

export
inline constexpr
std::string decode(std::string_view encoded) {
    std::string ret;
    ret.reserve(encoded.size());
    for (uz idx = 0; idx < encoded.length(); ++idx) {
        char cur = encoded[idx];
        if (cur == '%' && idx + 2 < encoded.length()) {
            cur = (hex_to_half(encoded[idx + 1]) << 4)
                + hex_to_half(encoded[idx + 2]);
            idx += 2;
        }
        ret.append(1, cur);
    }
    return ret;
} // <-- decode(encoded)

export
inline constexpr
std::string encode(std::string_view decoded) {
    static constexpr std::array escapees{
        ' ', ':', '/', '?', '#', '[', ']',
        '\t', '@', '!', '$', '&', '\'', '(',
        ')', '*', '+', ',', ';', '=', '%'
    }; // <-- escapeees
    std::string ret;
    ret.reserve(decoded.size() * 2);
    for (char c : decoded) {
        if (std::ranges::contains(escapees, c)) {
            ret.append(1, '%');
            ret.append(1, half_to_hex(c >> 4));
            ret.append(1, half_to_hex(c & 0x0f));
        } else {
            ret.append(1, c);
        }
    }
    return ret;
} // <-- encode(decoded)

static_assert(
    decode("%D0%B0%D0%BC%D0%BE%D0%BD%D0%B3%20%D0%B0%D1%81") == "амонг ас"
);
static_assert(
    encode("амонг ас") == "амонг%20ас" // cyrillic is not required to be escaped
);

} // <-- namespace dxx::http::url
